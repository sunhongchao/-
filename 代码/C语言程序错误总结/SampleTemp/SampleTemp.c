/************************************************************
QData 浮点转定点放大的倍数

************************************************************/
#include <stdio.h>
#define int16 short int
#define uint16 unsigned short int
#define Q_Data 64
//ADC转换值和温度的关系表0-1024
const int16 NTCTAB1[181]=
{  
	4, 4, 5, 5, 5, 5, 6, 6, 6, 7,  
	7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 
	12, 13, 14, 14, 15, 16, 17, 18, 19,20, 
    21, 22, 23, 24, 25, 27, 28, 29, 31, 32, 
    34, 36, 37, 39, 41, 
    43, 45, 47, 50, 52, 54, 57, 59, 62, 64,
    67, 70, 73, 76, 79,  
    83, 86, 90, 93, 97,101, 105, 109, 113, //5
    117,121, 126, 130, 135, 140, 145, 150, 155, 160, 165, 
	171, 176, 182, 188, 194, 200, 206, 212, 
	218, 224,  231, 237, 244, 251, 258, 265,
	272, 279, 286, 293,  300, 308, 315, 323, 
	330, 338, 345, 353, 361, 369,  376, 384, 
	392, 400, 408, 416, 424, 432, 439, 447,  
	455, 463, 471, 479, 487, 494, 502, 510, 
	518, 525,  533, 541, 548, 556, 563, 570, 
	578, 585, 592, 599,  606, 613, 620, 627, 
	634, 641, 647, 654, 660, 667,  673, 679, 
	685, 691, 697, 705, 709, 715, 721, 726, 
	732, 737, 742, 748, 753, 758, 763, 768, 
	772, 777,  782, 786, 791, 795, 800, 804, 
	808, 812, 816, 820,  824, 
 };//测量电阻为1K数据表 

	
const int16 NTCTAB[141]=
{
3717,3697,3676,3654,3631,3607,3582,3557,3530,3503,
3474,3445,3415,3384,3352,3319,3285,3251,3215,3179,	
3142,3104,3065,3025,2985,2944,2903,2861,2818,2775,
2731,2686,2642,2597,2552,2506,2460,2415,2369,2322,
2277,2230,2184,2139,2093,2048,2002,1957,1913,1869,
1825,1782,1739,1697,1655,1614,1574,1534,1495,1456,
1418,1381,1344,1309,1273,1239,1205,1172,1140,1109,
1078,1048,1019,990,962,935,908,882,857,833,
809,786,763,741,720,699,679,660,640,622,
604,587,570,553,537,522,507,492,478,465,
451,439,426,414,402,391,380,369,359,349,
339,330,320,311,303,295,286,279,271,264,
256,249,243,236,230,224,218,212,206,201,
196,191,186,181,176,172,167,163,159,155,
151,

}; 



#define Data_125 NTCTAB[140]
#define Data_N55 NTCTAB[0]
//二分查表从高到低排序查表 
void Lookup_TAB(int16 data,const int16 *TABLE,int16 *aptr) 
{   
	uint16 i;  
	int16 *eptr=(int16 *)&TABLE[140]; //高端指针 
    int16 *sptr=(int16 *)TABLE;  //低端指针 
	int16 *ptr;       //查数指针 

 for(i=0;i<8;i++)     	 //搜索全表 181
 {   
	 ptr = sptr+((eptr-sptr)>>1);
	
    if(*ptr<data) eptr = ptr; //后半区 //sptr = ptr; 低到高排序 
	else 
		if(*ptr>data) sptr = ptr;//前半区 //eptr = ptr; 低到高排序 
	else if(*ptr==data)    //查到相等的节点   
		 {    
			 aptr[2] = *ptr;   //Y1   
			 aptr[1] = *(ptr+1);  //Y2    
			 aptr[0] = (int16)(ptr-TABLE);//X1
			return ;// break;  
		 }       
		 if((eptr-sptr)==1) //查到节点的范围e-f=1
		 {
			 aptr[2] = *sptr;  //Y1    
		     aptr[1] = *eptr;  //Y2    
			 aptr[0] = (int16)(sptr-TABLE);//X1  
			 return ; //break;
		 }  
	}
} 

//分段线性插值data为从AD中读取的数值，Temp是
int16 LinearInsert(uint16 data,const int16 *TABLE)
{
	int16 Temp,Array[3];
	if(data<Data_N55) //beyond lowest temperature
		if(data>Data_125)
		{
			Lookup_TAB(data,TABLE,Array);
			//将数据放大Q_Data=64倍后计算10位ADC正好16位
			if(data==Array[2]) Temp=(Array[0]-20)*Q_Data;//采样数据正好与表中数据相等
			else Temp=(Array[0]-20)*Q_Data+Q_Data*(data-Array[2])/(Array[1]-Array[2]);
		}
		else Temp=0x7FFF;//underflow
		else Temp=0x7FFF;//overflow
		return Temp;
}
void Temperature_Measure()
{
	float temp;
	int16 Array[3];
	temp=(float)LinearInsert(3675,NTCTAB)/Q_Data;
	printf("%f\n",temp);
	temp=(float)LinearInsert(155,NTCTAB)/Q_Data;
	printf("%f\n",temp);
	Lookup_TAB(155,NTCTAB,Array);
	printf("%d\n%d\n%d\n",Array[0],Array[1],Array[2]);
}
int main(void)
{
	Temperature_Measure();
	while(1);
	return 0;
}
